# -*- coding: utf-8 -*-
"""Assignment4_Fast_BilateralFilter.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Px6FQu6ymnqeX02dO3PqHunLzJ9y3duE
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt
import math
import time

def my_BF(img):

    kernel_size = 11
    sigmad = 20
    sigmai = 30
    h,w = img.shape[:2]

    blue_img_fil = np.zeros((h, w), dtype=np.uint8)
    green_img_fil = np.zeros((h, w), dtype=np.uint8)
    red_img_fil = np.zeros((h, w), dtype=np.uint8)

    blue_img_row = np.zeros((h, w), dtype=np.uint8)
    green_img_row = np.zeros((h, w), dtype=np.uint8)
    red_img_row = np.zeros((h, w), dtype=np.uint8)
    
    blue_img, green_img, red_img = cv2.split(img)

    sigmad_sq = 2*sigmad*sigmad
    
    sigmai_sq = 2*sigmai*sigmai
    
        
    k = int((kernel_size)/2)
    kernel = np.zeros([1,kernel_size])

    
    for i in range(-k,k+1):
        d_sq = (i*i)
        kernel[0,i+k] = (1/math.sqrt(math.pi * sigmad_sq)) * math.exp(-(d_sq/sigmad_sq))


    for j in range (k,w-k):
            
        blue_img_seg = blue_img[:, j - k : j + k + 1]
        blue_img_dif = np.subtract(blue_img_seg,np.multiply(np.reshape(blue_img_seg[:, k],(h,1)),np.ones([h,kernel_size])))
        blue_img_ker = (1/math.sqrt(math.pi * sigmai_sq)) * np.exp(-((blue_img_dif / sigmai) ** 2) * 0.5)
        blue_img_w = np.multiply(kernel, blue_img_ker)
        blue_img_pixs = np.multiply(blue_img_seg, blue_img_w)
        blue_img_p = np.sum(blue_img_pixs,axis=1) / np.sum(blue_img_w,axis=1)
        blue_img_row[:, j] = blue_img_p


        green_img_seg = green_img[:, j - k : j + k + 1]
        green_img_dif = np.subtract(green_img_seg,np.multiply(np.reshape(green_img_seg[:, k],(h,1)),np.ones([h,kernel_size])))
        green_img_ker = (1/math.sqrt(math.pi * sigmai_sq)) * np.exp(-((green_img_dif / sigmai) ** 2) * 0.5)
        green_img_w = np.multiply(kernel, green_img_ker)
        green_img_pixs = np.multiply(green_img_seg, green_img_w)
        green_img_p = np.sum(green_img_pixs,axis=1) / np.sum(green_img_w,axis=1)
        green_img_row[:, j] = green_img_p


        red_img_seg = red_img[:, j - k : j + k + 1]
        red_img_dif = np.subtract(red_img_seg,np.multiply(np.reshape(red_img_seg[:, k],(h,1)),np.ones([h,kernel_size])))
        red_img_ker = (1/math.sqrt(math.pi * sigmai_sq)) * np.exp(-((red_img_dif / sigmai) ** 2) * 0.5)
        red_img_w = np.multiply(kernel, red_img_ker)
        red_img_pixs = np.multiply(red_img_seg, red_img_w)
        red_img_p = np.sum(red_img_pixs,axis=1) / np.sum(red_img_w,axis=1)
        red_img_row[:, j] = red_img_p        

        
    kernel = np.transpose(kernel)    


    for i in range (k,h-k):
            
        blue_img_seg = blue_img_row[i - k : i + k + 1,:]
        blue_img_dif = np.subtract(blue_img_seg,np.multiply(np.reshape(blue_img_seg[k, :],(1,w)),np.ones([kernel_size,w])))
        blue_img_ker = (1/math.sqrt(math.pi * sigmai_sq)) * np.exp(-((blue_img_dif / sigmai) ** 2) * 0.5)
        blue_img_w = np.multiply(kernel, blue_img_ker)
        blue_img_pixs = np.multiply(blue_img_seg, blue_img_w)
        blue_img_p = np.sum(blue_img_pixs,axis=0) / np.sum(blue_img_w,axis=0)
        blue_img_fil[i, :] = blue_img_p     

        green_img_seg = green_img_row[i - k : i + k + 1,:]
        green_img_dif = np.subtract(green_img_seg,np.multiply(np.reshape(green_img_seg[k, :],(1,w)),np.ones([kernel_size,w])))
        green_img_ker = (1/math.sqrt(math.pi * sigmai_sq)) * np.exp(-((green_img_dif / sigmai) ** 2) * 0.5)
        green_img_w = np.multiply(kernel, green_img_ker)
        green_img_pixs = np.multiply(green_img_seg, green_img_w)
        green_img_p = np.sum(green_img_pixs,axis=0) / np.sum(green_img_w,axis=0)
        green_img_fil[i, :] = green_img_p     


        red_img_seg = red_img_row[i - k : i + k + 1,:]
        red_img_dif = np.subtract(red_img_seg,np.multiply(np.reshape(red_img_seg[k, :],(1,w)),np.ones([kernel_size,w])))
        red_img_ker = (1/math.sqrt(math.pi * sigmai_sq)) * np.exp(-((red_img_dif / sigmai) ** 2) * 0.5)
        red_img_w = np.multiply(kernel, red_img_ker)
        red_img_pixs = np.multiply(red_img_seg, red_img_w)
        red_img_p = np.sum(red_img_pixs,axis=0) / np.sum(red_img_w,axis=0)
        red_img_fil[i, :] = red_img_p     


    
    out_img = cv2.merge([blue_img_fil,green_img_fil,red_img_fil])

    
    return out_img

if __name__ == "__main__":

    im = cv2.imread('rome.jpg')
    im1 = my_BF(im)
    cv2.imwrite('Denoised_rome.jpg',im1)